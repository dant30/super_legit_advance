while i have the following project structure, we need to work on the pages and their components so with the attached files and the codes that i will  provide lets work on the customer pages and their components   ,                                                                                                                   super_legit_advance/
├── backend/                      # Django backend API (to be deployed separate)
│   ├── manage.py
│   ├── pyproject.toml           # Modern Python config
│   ├── Dockerfile
│   ├── docker-compose.yml       # Backend-only compose
│   ├── .env.example
│   ├── README.md
│   ├── requirements/
│   │   ├── base.txt
│   │   ├── dev.txt
│   │   └── prod.txt
│   ├── apps/
│   │   ├── __init__.py
│   │   ├── users/               # Authentication & user management
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── user.py
│   │   │   │   └── staff.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   ├── __init__.py
│   │   │   │   └── user.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   ├── tests/
│   │   │   │   └── __init__.py
│   │   │   └── permissions.py
│   │   ├── loans/               # Core loans functionality
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── loan.py
│   │   │   │   ├── application.py
│   │   │   │   └── collateral.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── loan.py
│   │   │   │   └── application.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   ├── tests/
│   │   │   │   └── __init__.py
│   │   │   └── calculators/
│   │   │       ├── __init__.py
│   │   │       └── loan_calculator.py
│   │   ├── customers/           # Customer management
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── customer.py
│   │   │   │   ├── guarantor.py
│   │   │   │   └── employment.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── customer.py
│   │   │   │   └── guarantor.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   ├── tests/
│   │   │   │   └── __init__.py
│   │   │   └── validators/
│   │   │       ├── __init__.py
│   │   │       └── customer_validator.py
│   │   ├── repayments/          # Repayment tracking
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── repayment.py
│   │   │   │   ├── schedule.py
│   │   │   │   └── penalty.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── repayment.py
│   │   │   │   └── schedule.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   ├── tests/
│   │   │   │   └── __init__.py
│   │   │   └── calculators/
│   │   │       ├── __init__.py
│   │   │       └── repayment_calculator.py
│   │   ├── mpesa/               # M-Pesa Payment Integration
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── payment.py
│   │   │   │   ├── transaction.py
│   │   │   │   └── callback.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── payment.py
│   │   │   │   └── transaction.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   ├── tests/
│   │   │   │   └── __init__.py
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── mpesa_service.py
│   │   │   │   ├── stk_push.py
│   │   │   │   └── callback_handler.py
│   │   │   └── utils/
│   │   │       ├── __init__.py
│   │   │       ├── security.py
│   │   │       └── helpers.py
│   │   ├── notifications/       # SMS & Email Notifications
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── notification.py
│   │   │   │   ├── template.py
│   │   │   │   └── sms_log.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── notification.py
│   │   │   │   └── template.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   ├── tests/
│   │   │   │   └── __init__.py
│   │   │   ├── services/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── sms_service.py
│   │   │   │   ├── email_service.py
│   │   │   │   └── notification_service.py
│   │   │   ├── templates/
│   │   │   │   └── sms/
│   │   │   │       ├── loan_approved.txt
│   │   │   │       ├── payment_reminder.txt
│   │   │   │       └── overdue_notice.txt
│   │   │   └── tasks/
│   │   │       ├── __init__.py
│   │   │       ├── send_sms.py
│   │   │       └── send_payment_reminders.py
│   │   ├── reports/             # Reporting module
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── views/
│   │   │   │   ├── __init__.py
│   │   │   │   └── api.py
│   │   │   ├── serializers/
│   │   │   │   └── __init__.py
│   │   │   ├── urls.py
│   │   │   ├── templates/
│   │   │   │   └── pdf/
│   │   │   │       ├── loan_agreement.html
│   │   │   │       └── repayment_schedule.html
│   │   │   ├── generators/
│   │   │   │   ├── __init__.py
│   │   │   │   ├── pdf_generator.py
│   │   │   │   └── excel_generator.py
│   │   │   └── utils.py
│   │   ├── audit/               # Audit logging
│   │   │   ├── __init__.py
│   │   │   ├── apps.py
│   │   │   ├── models/
│   │   │   │   ├── __init__.py
│   │   │   │   └── audit_log.py
│   │   │   ├── views/
│   │   │   │   └── __init__.py
│   │   │   ├── urls.py
│   │   │   ├── admin.py
│   │   │   ├── migrations/
│   │   │   │   └── __init__.py
│   │   │   └── middleware.py
│   │   └── core/                # Shared utilities
│   │       ├── __init__.py
│   │       ├── apps.py
│   │       ├── models/
│   │       │   ├── __init__.py
│   │       │   └── base.py
│   │       ├── utils/
│   │       │   ├── __init__.py
│   │       │   ├── permissions.py
│   │       │   ├── validators.py
│   │       │   ├── helpers.py
│   │       │   └── date_utils.py
│   │       ├── mixins/
│   │       │   ├── __init__.py
│   │       │   └── api_mixins.py
│   │       ├── management/
│   │       │   └── commands/
│   │       │       ├── __init__.py
│   │       │       ├── send_reminders.py
│   │       │       ├── generate_reports.py
│   │       │       └── process_overdue.py
│   │       └── constants.py
│   ├── super_legit_advance/     # Django project
│   │   ├── __init__.py
│   │   ├── asgi.py
│   │   ├── wsgi.py
│   │   ├── urls.py
│   │   └── settings/
│   │       ├── __init__.py
│   │       ├── base.py
│   │       ├── development.py
│   │       ├── production.py
│   │       └── testing.py
│   ├── media/                   # Uploaded files
│   │   ├── documents/
│   │   ├── contracts/
│   │   └── identity_docs/
│   ├── static/                  # Static files
│   │   └── admin/
│   ├── scripts/                 # Deployment scripts
│   │   ├── deploy.sh
│   │   ├── backup_db.sh
│   │   └── setup_dev.sh
│   └── nginx/
│       └── nginx.conf
|
|
├── frontend/                    # React frontend (office interface and to be deployed separate)
│   ├── package.json
│   ├── package-lock.json
│   ├── Dockerfile
│   ├── vite.config.js
│   ├── tailwind.config.js
│   ├── postcss.config.js
│   ├── tsconfig.json
│   ├── index.html
│   ├── .env.example
│   ├── public/
│   │   ├── favicon.ico
│   │   ├── logo.png
│   │   └── manifest.json
│   └── src/
│       ├── main.tsx
│       ├── App.tsx
│       ├── App.css
│       ├── vite-env.d.ts
│       ├── lib/
│       │   ├── api/
│       │   │   ├── auth.ts
│       │   │   ├── loans.ts
│       │   │   ├── audit.ts
│       │   │   ├── notification.ts
│       │   │   ├── reports.ts
│       │   │   ├── customers.ts
│       │   │   ├── repayments.ts
│       │   │   └── mpesa.ts
│       │   ├── utils/
│       │   │   ├── formatters.ts
│       │   │   ├── theme.ts
│       │   │   ├── reportUtils.ts
│       │   │   ├── validators.ts
│       │   │   ├── cn.ts
│       │   │   └── constants.ts
│       │   └── axios.ts
│       ├── components/
│       │   ├── layout/
│       │   │   ├── Header.tsx
│       │   │   ├── Sidebar.tsx
│       │   │   ├── Footer.tsx
│       │   │   └── Layout.tsx
│       │   ├── ui/
│       │   │   ├── Button/
│       │   │   │   ├── Button.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Card/
│       │   │   │   ├── Card.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Table/
│       │   │   │   ├── Table.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Input/
│       │   │   │   ├── Input.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Modal/
│       │   │   │   ├── Modal.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Checkbox/
│       │   │   │   ├── Checkbox.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Badge/
│       │   │   │   ├── Badge.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Alert/
│       │   │   │   ├── Alert.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Tooltip/
│       │   │   │   ├── Tooltip.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Toast/
│       │   │   │   ├── Toast.tsx
|       |   |   |   ├── ToastProvider.tsx
│       │   │   │   └── index.ts
│       │   │   ├── Tabs/
│       │   │   │   ├── Tabs.tsx
│       │   │   │   └── index.ts
│       │   │   |── Accordion/
│       │   │   |   ├── Accordion.tsx
│       │   │   |   └── index.ts
│       │   │   ├── Theme/
│       │   │   │   ├── ThemeInitializer.tsx
│       │   │   │   └── index.ts
│       │   │   └── Select/
│       │   │        ├── Select.tsx
│       │   │        └── index.ts
│       │   ├── shared/
│       │   │   ├── Loading.tsx
│       │   │   ├── Error.tsx
│       │   │   ├── EmptyState.tsx
│       │   │   ├── ConfirmDialog.tsx
│       │   │   ├── Pagination.tsx
│       │   │   ├── Breadcrumbs.tsx            
│       │   │   └── FileUpload.tsx
│       │   ├── dashboard/
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx
│       │   ├── reports/
│       │   │   ├── folder1/
│       │   │   │   ├── component1.tsx 
│       │   │   │   ├── component2.tsx   
│       │   │   │   └── component_n.tsx  
│       │   │   ├── folder2/
│       │   │   │   ├── component1.tsx 
│       │   │   │   ├── component2.tsx   
│       │   │   │   └── component_n.tsx    
│       │   │   ├── folder3/
│       │   │   │   ├── component1.tsx 
│       │   │   │   ├── component2.tsx   
│       │   │   │   └── component_n.tsx  
│       │   │   └── folder4/
│       │   │       ├── component1.tsx 
│       │   │       ├── component2.tsx   
│       │   │       └── component_n.tsx         
│       │   ├── loans/
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx       
│       │   ├── auth/                 
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx         
|       |   ├── admin/
│       │   │   ├── folder1/
│       │   │   │   ├── component1.tsx 
│       │   │   │   ├── component2.tsx   
│       │   │   │   └── component_n.tsx  
│       │   │   ├── folder2/
│       │   │   │   ├── component1.tsx 
│       │   │   │   ├── component2.tsx   
│       │   │   │   └── component_n.tsx    
│       │   │   ├── folder3/
│       │   │   │   ├── component1.tsx 
│       │   │   │   ├── component2.tsx   
│       │   │   │   └── component_n.tsx  
│       │   │   └── folder4/
│       │   │       ├── component1.tsx 
│       │   │       ├── component2.tsx   
│       │   │       └── component_n.tsx   
│       │   ├── customers/
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx
│       │   │── notifications/
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx
│       │   │── payments/
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx
│       │   └── staff_settings/                        # NEW
│       │           ├── component1.tsx
│       │           ├── component2.tsx
│       │           └── component_n.tsx
│       ├── pages/
│       │   ├── Dashboard.tsx                 #(overview of all pages)
│       │   ├── Login.tsx
│       │   ├── NotFound.tsx
│       │   ├── Unauthorized.tsx
|       |   ├── ActivityLog.tsx
|       |   ├── Maintenance.tsx                # Maintenance mode page
│       │   ├── docs/                          # ADD THIS DIRECTORY
│       │   │   ├── ApiDocumentation.tsx       # API docs with Swagger UI
│       │   │   ├── UserGuide.tsx              # User manual
│       │   │   ├── SystemGuide.tsx            # System admin guide
│       │   │   └── Tutorials.tsx
│       │   ├── legal/                     # ADD THIS
│       │   │   ├── TermsOfService.tsx
│       │   │   ├── PrivacyPolicy.tsx
│       │   │   ├── DataProtection.tsx
│       │   │   └── AcceptableUse.tsx
│       │   ├── support/                       # ADD THIS DIRECTORY
│       │   │   ├── HelpCenter.tsx             # Main help page
│       │   │   ├── ContactSupport.tsx         # Contact form
│       │   │   ├── SystemStatus.tsx           # System uptime/status
│       │   │   └── FeatureRequest.tsx         # Request new features
│       │   ├── auth/
|       |   |   ├── ForgotPassword.tsx       # Request password reset
|       |   |   ├── ResetPassword.tsx        # Reset password with token
|       |   |   ├── VerifyEmail.tsx          # Email verification (optional)
|       |   |   └── TwoFactorAuth.tsx        # 2FA setup/verification
│       │   ├── admin/
|       |   |   ├── Staff/
|       |   |   │   ├── List.tsx
|       |   |   │   ├── Create.tsx
|       |   |   │   ├── Edit.tsx
|       |   |   │   ├── Detail.tsx
|       |   |   │   ├── Performance.tsx     # KPIs, collections handled
|       |   |   │   ├── Tasks.tsx           # Assign / track tasks
|       |   |   │   └── Schedule.tsx        # Shifts / work calendar
|       |   |   ├── settings/
|       |   |   |   ├── Configuration.tsx       # System settings
|       |   |   |   ├── LoanProducts.tsx        # Manage loan products
|       |   |   |   ├── InterestRates.tsx       # Manage interest rates
|       |   |   |   └── BackupRestore.tsx       # System backup/restore
|       |   |   ├── Roles/
|       |   |   |   ├── List.tsx            # List roles & permissions
|       |   |   |   ├── Create.tsx          # Create new role
|       |   |   |   └── Assign.tsx          # Assign roles to users
│       │   │   └── AuditLogs/
|       |   |       └── List.tsx 
│       │   ├── loans/
│       │   │   ├── routes.tsx
│       │   │   ├── page1.tsx
│       │   │   ├── page2.tsx
│       │   │   └── maybe_page_n.tsx
│       │   ├── customers/
│       │   │   ├── routes.tsx
│       │   │   ├── page1.tsx
│       │   │   ├── page2.tsx
│       │   │   └── maybe_page_n.tsx
│       │   ├── repayments/
│       │   │   ├── routes.tsx
│       │   │   ├── page1.tsx
│       │   │   ├── page2.tsx
│       │   │   └── maybe_page_n.tsx
│       │   ├── reports/
│       │   │   ├── routes.tsx
│       │   │   ├── page1.tsx
│       │   │   ├── page2.tsx
│       │   │   └── maybe_page_n.tsx
│       │   ├── notifications/
│       │   │   ├── routes.tsx
│       │   │   ├── page1.tsx
│       │   │   ├── page2.tsx
│       │   │   └── maybe_page_n.tsx
│       │   └── staff_settings/
│       │       ├── routes.tsx
│       │       ├── Profile.tsx
│       │       └── maybe_page_n.tsx
│       ├── hooks/
│       │   ├── useAuth.ts
│       │   ├── useMediaQuery.ts
│       │   ├── useLoans.ts
│       │   ├── useAudit.ts
│       │   ├── useNotifications.ts
│       │   ├── useRepayments.ts
│       │   ├── useReports.ts
│       │   ├── useCustomers.ts
│       │   └── useMpesa.ts
│       ├── store/
│       │   ├── slices/
│       │   │   ├── authSlice.ts
│       │   │   ├── loanSlice.ts
│       │   │   ├── auditSlice.ts
│       │   │   ├── customerSlice.ts
│       │   │   ├── notificationSlice.ts
│       │   │   ├── reportsSlice.ts
│       │   │   ├── repaymentSlice.ts
│       │   │   ├── mpesaSlice.ts
│       │   │   └── uiSlice.ts
│       │   ├── store.ts
│       │   └── selectors.ts
│       ├── types/
│       │   ├── api.ts
│       │   ├── auth.ts
│       │   ├── audit.ts
│       │   ├── notifications.ts
│       │   ├── repayments.ts
│       │   ├── reports.ts
│       │   ├── loans.ts
│       │   ├── customers.ts
│       │   └── mpesa.ts
│       ├── styles/
│       │   ├── tailwind.css
│       │   ├── globals.css
│       │   ├── components.css
│       │   └── animations.css
│       └── router/
│           ├── routes.tsx
│           ├── PrivateRoute.tsx
│           └── AdminRoute.tsx
├── docker-compose.yml           # Full stack development
├── docker-compose.prod.yml      # Production deployment
├── .gitignore
├── README.md
└── CHANGELOG.md     and for customer type, slice, api and hook i have  // frontend/src/lib/api/customers.ts
import axiosInstance from '@/lib/axios'

/* =====================================================
 * Core Types
 * ===================================================== */

export interface Customer {
  id: string
  customer_number: string
  first_name: string
  last_name: string
  middle_name?: string
  full_name: string
  email?: string
  phone_number: string
  date_of_birth: string
  gender: 'M' | 'F' | 'O'
  id_number: string
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE' | 'ALIEN_CARD'
  id_expiry_date?: string
  nationality: string
  physical_address: string
  postal_address?: string
  county: string
  sub_county: string
  ward?: string
  bank_name?: string
  bank_account_number?: string
  bank_branch?: string
  marital_status?: 'SINGLE' | 'MARRIED' | 'DIVORCED' | 'WIDOWED' | 'SEPARATED'
  status: 'ACTIVE' | 'INACTIVE' | 'BLACKLISTED' | 'DECEASED'
  credit_score: number
  risk_level: 'LOW' | 'MEDIUM' | 'HIGH'
  age: number
  is_active: boolean
  is_blacklisted: boolean
  total_loans: number
  active_loans: number
  total_loan_amount: number
  outstanding_balance: number
  loan_performance: number
  registration_date: string
  last_updated: string
  created_at: string
  updated_at: string
  notes?: string
  referred_by?: string
  user?: string
  created_by?: string
  updated_by?: string
}

export interface Employment {
  id: string
  customer: string
  employment_type: 'EMPLOYED' | 'SELF_EMPLOYED' | 'UNEMPLOYED' | 'STUDENT' | 'RETIRED'
  sector: string
  occupation: string
  employer_name?: string
  employer_address?: string
  employer_phone?: string
  employer_email?: string
  job_title?: string
  department?: string
  employee_number?: string
  date_employed?: string
  years_of_service: number
  monthly_income: number
  other_income: number
  total_monthly_income: number
  payment_frequency: string
  next_pay_date?: string
  business_name?: string
  business_type?: string
  business_registration?: string
  business_start_date?: string
  number_of_employees: number
  is_verified: boolean
  verification_date?: string
  verification_method?: string
  verification_notes?: string
  employment_letter?: string
  pay_slips?: string
  business_permit?: string
  notes?: string
  created_at: string
  updated_at: string
}

export interface Guarantor {
  id: string
  customer: string
  first_name: string
  middle_name?: string
  last_name: string
  full_name: string
  phone_number: string
  email?: string
  physical_address: string
  county: string
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE'
  id_number: string
  guarantor_type: 'PERSONAL' | 'CORPORATE' | 'INSTITUTIONAL'
  relationship: 'SPOUSE' | 'PARENT' | 'SIBLING' | 'FRIEND' | 'COLLEAGUE' | 'RELATIVE' | 'OTHER'
  occupation: string
  employer?: string
  monthly_income: number
  id_document?: string
  passport_photo?: string
  is_active: boolean
  verification_status: 'PENDING' | 'VERIFIED' | 'REJECTED'
  is_verified?: boolean
  verification_date?: string
  verification_notes?: string
  notes?: string
  created_at: string
  updated_at: string
}

/* =====================================================
 * API Response Types
 * ===================================================== */

export interface CustomerListResponse {
  results: Customer[]
  count: number
  next: string | null
  previous: string | null
}

export interface CustomerDetailResponse extends Customer {
  loan_statistics?: {
    total_loans: number
    active_loans: number
    total_borrowed: number
    total_outstanding: number
    total_repaid: number
  }
  guarantors?: Guarantor[]
  employment?: Employment
}

export interface CustomerStatsResponse {
  total_customers: number
  active_customers: number
  blacklisted_customers: number
  new_customers_today: number
  gender_distribution: Array<{ gender: string; count: number }>
  status_distribution: Array<{ status: string; count: number }>
  top_counties: Array<{ county: string; count: number }>
  monthly_registrations: Array<{ month: string; count: number }>
  loan_statistics: {
    customers_with_loans: number
    customers_with_active_loans: number
    customers_with_overdue_loans: number
  }
}

/* =====================================================
 * API Parameters
 * ===================================================== */

export interface CustomerListParams {
  page?: number
  page_size?: number
  search?: string
  status?: string
  gender?: string
  marital_status?: string
  county?: string
  risk_level?: string
  active?: boolean | string
  blacklisted?: boolean | string
  has_loans?: boolean | string
  start_date?: string
  end_date?: string
  ordering?: string
}

export interface CustomerCreateData {
  first_name: string
  last_name: string
  middle_name?: string
  date_of_birth: string
  gender: 'M' | 'F' | 'O'
  marital_status?: 'SINGLE' | 'MARRIED' | 'DIVORCED' | 'WIDOWED' | 'SEPARATED'
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE' | 'ALIEN_CARD'
  id_number: string
  id_expiry_date?: string
  nationality?: string
  phone_number: string
  confirm_phone_number?: string
  email?: string
  confirm_email?: string
  postal_address?: string
  physical_address: string
  county: string
  sub_county: string
  ward?: string
  bank_name?: string
  bank_account_number?: string
  bank_branch?: string
  notes?: string
  referred_by?: string
  create_user_account?: boolean
  user_password?: string
  id_document?: File
  passport_photo?: File
  signature?: File
}

export interface CustomerUpdateData {
  first_name?: string
  last_name?: string
  middle_name?: string
  date_of_birth?: string
  gender?: 'M' | 'F' | 'O'
  marital_status?: 'SINGLE' | 'MARRIED' | 'DIVORCED' | 'WIDOWED' | 'SEPARATED'
  id_type?: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE' | 'ALIEN_CARD'
  id_expiry_date?: string
  nationality?: string
  phone_number?: string
  email?: string
  postal_address?: string
  physical_address?: string
  county?: string
  sub_county?: string
  ward?: string
  bank_name?: string
  bank_account_number?: string
  bank_branch?: string
  status?: 'ACTIVE' | 'INACTIVE' | 'BLACKLISTED' | 'DECEASED'
  credit_score?: number
  risk_level?: 'LOW' | 'MEDIUM' | 'HIGH'
  notes?: string
  referred_by?: string
  id_document?: File
  passport_photo?: File
  signature?: File
  current_password?: string
}

export interface EmploymentCreateData extends Partial<Employment> {}

export interface GuarantorCreateData {
  first_name: string
  middle_name?: string
  last_name: string
  phone_number: string
  confirm_phone_number?: string
  email?: string
  physical_address: string
  county: string
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE'
  id_number: string
  guarantor_type: 'PERSONAL' | 'CORPORATE' | 'INSTITUTIONAL'
  relationship: 'SPOUSE' | 'PARENT' | 'SIBLING' | 'FRIEND' | 'COLLEAGUE' | 'RELATIVE' | 'OTHER'
  occupation: string
  employer?: string
  monthly_income: number
  id_document?: File
  passport_photo?: File
  notes?: string
}

/* =====================================================
 * API Class
 * ===================================================== */

class CustomerAPI {
  private baseURL = '/customers'

  /* ===== CUSTOMER ENDPOINTS ===== */

  async getCustomers(params?: CustomerListParams): Promise<CustomerListResponse> {
    try {
      const response = await axiosInstance.get<CustomerListResponse>(this.baseURL, {
        params,
      })
      return response.data
    } catch (error) {
      console.error('Error fetching customers:', error)
      throw error
    }
  }

  async getCustomer(id: string): Promise<CustomerDetailResponse> {
    try {
      const response = await axiosInstance.get<CustomerDetailResponse>(`${this.baseURL}/${id}/`)
      return response.data
    } catch (error) {
      console.error('Error fetching customer:', error)
      throw error
    }
  }

  async createCustomer(data: CustomerCreateData): Promise<Customer> {
    try {
      const formData = new FormData()

      // Append all fields to formData
      Object.entries(data).forEach(([key, value]) => {
        if (value instanceof File) {
          formData.append(key, value)
        } else if (value !== undefined && value !== null) {
          formData.append(key, String(value))
        }
      })

      const response = await axiosInstance.post<Customer>(`${this.baseURL}/create/`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      })
      return response.data
    } catch (error) {
      console.error('Error creating customer:', error)
      throw error
    }
  }

  async updateCustomer(id: string, data: CustomerUpdateData): Promise<Customer> {
    try {
      const formData = new FormData()

      // Append all fields to formData
      Object.entries(data).forEach(([key, value]) => {
        if (value instanceof File) {
          formData.append(key, value)
        } else if (value !== undefined && value !== null) {
          formData.append(key, String(value))
        }
      })

      const response = await axiosInstance.put<Customer>(`${this.baseURL}/${id}/`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      })
      return response.data
    } catch (error) {
      console.error('Error updating customer:', error)
      throw error
    }
  }

  async deleteCustomer(id: string): Promise<void> {
    try {
      await axiosInstance.delete(`${this.baseURL}/${id}/`)
    } catch (error) {
      console.error('Error deleting customer:', error)
      throw error
    }
  }

  async searchCustomers(query: string, searchType?: string): Promise<Customer[]> {
    try {
      const response = await axiosInstance.get<{ results: Customer[] }>(
        `${this.baseURL}/search/`,
        {
          params: {
            q: query,
            type: searchType || 'basic',
          },
        }
      )
      return response.data.results
    } catch (error) {
      console.error('Error searching customers:', error)
      throw error
    }
  }

  async getCustomerStats(): Promise<CustomerStatsResponse> {
    try {
      const response = await axiosInstance.get<CustomerStatsResponse>(`${this.baseURL}/stats/`)
      return response.data
    } catch (error) {
      console.error('Error fetching customer stats:', error)
      throw error
    }
  }

  async blacklistCustomer(id: string, reason: string): Promise<Customer> {
    try {
      const response = await axiosInstance.post<Customer>(
        `${this.baseURL}/${id}/blacklist/`,
        { reason }
      )
      return response.data
    } catch (error) {
      console.error('Error blacklisting customer:', error)
      throw error
    }
  }

  async activateCustomer(id: string): Promise<Customer> {
    try {
      const response = await axiosInstance.post<Customer>(`${this.baseURL}/${id}/activate/`)
      return response.data
    } catch (error) {
      console.error('Error activating customer:', error)
      throw error
    }
  }

  async exportCustomers(format: 'excel' | 'csv', filters?: any): Promise<Blob> {
    try {
      const response = await axiosInstance.get(`${this.baseURL}/export/`, {
        params: {
          format,
          ...filters,
        },
        responseType: 'blob',
      })
      return response.data
    } catch (error) {
      console.error('Error exporting customers:', error)
      throw error
    }
  }

  async importCustomers(file: File): Promise<any> {
    try {
      const formData = new FormData()
      formData.append('file', file)

      const response = await axiosInstance.post(`${this.baseURL}/import/`, formData, {
        headers: {
          'Content-Type': 'multipart/form-data',
        },
      })
      return response.data
    } catch (error) {
      console.error('Error importing customers:', error)
      throw error
    }
  }

  /* ===== EMPLOYMENT ENDPOINTS ===== */

  async getEmployment(customerId: string): Promise<Employment> {
    try {
      const response = await axiosInstance.get<Employment>(
        `${this.baseURL}/${customerId}/employment/`
      )
      return response.data
    } catch (error) {
      console.error('Error fetching employment:', error)
      throw error
    }
  }

  async updateEmployment(customerId: string, data: EmploymentCreateData): Promise<Employment> {
    try {
      const formData = new FormData()

      Object.entries(data).forEach(([key, value]) => {
        if (value instanceof File) {
          formData.append(key, value)
        } else if (value !== undefined && value !== null) {
          formData.append(key, String(value))
        }
      })

      const response = await axiosInstance.put<Employment>(
        `${this.baseURL}/${customerId}/employment/update/`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      )
      return response.data
    } catch (error) {
      console.error('Error updating employment:', error)
      throw error
    }
  }

  /* ===== GUARANTOR ENDPOINTS ===== */

  async getGuarantors(customerId: string): Promise<Guarantor[]> {
    try {
      const response = await axiosInstance.get<{ results: Guarantor[] }>(
        `${this.baseURL}/${customerId}/guarantors/`
      )
      return response.data.results
    } catch (error) {
      console.error('Error fetching guarantors:', error)
      throw error
    }
  }

  async createGuarantor(customerId: string, data: GuarantorCreateData): Promise<Guarantor> {
    try {
      const formData = new FormData()

      Object.entries(data).forEach(([key, value]) => {
        if (value instanceof File) {
          formData.append(key, value)
        } else if (value !== undefined && value !== null) {
          formData.append(key, String(value))
        }
      })

      const response = await axiosInstance.post<Guarantor>(
        `${this.baseURL}/${customerId}/guarantors/create/`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      )
      return response.data
    } catch (error) {
      console.error('Error creating guarantor:', error)
      throw error
    }
  }

  async getGuarantor(id: string): Promise<Guarantor> {
    try {
      const response = await axiosInstance.get<Guarantor>(`${this.baseURL}/guarantors/${id}/`)
      return response.data
    } catch (error) {
      console.error('Error fetching guarantor:', error)
      throw error
    }
  }

  async updateGuarantor(id: string, data: Partial<GuarantorCreateData>): Promise<Guarantor> {
    try {
      const formData = new FormData()

      Object.entries(data).forEach(([key, value]) => {
        if (value instanceof File) {
          formData.append(key, value)
        } else if (value !== undefined && value !== null) {
          formData.append(key, String(value))
        }
      })

      const response = await axiosInstance.put<Guarantor>(
        `${this.baseURL}/guarantors/${id}/`,
        formData,
        {
          headers: {
            'Content-Type': 'multipart/form-data',
          },
        }
      )
      return response.data
    } catch (error) {
      console.error('Error updating guarantor:', error)
      throw error
    }
  }

  async deleteGuarantor(id: string): Promise<void> {
    try {
      await axiosInstance.delete(`${this.baseURL}/guarantors/${id}/`)
    } catch (error) {
      console.error('Error deleting guarantor:', error)
      throw error
    }
  }

  async verifyGuarantor(
    id: string,
    action: 'verify' | 'reject',
    notes: string
  ): Promise<Guarantor> {
    try {
      const response = await axiosInstance.post<Guarantor>(
        `${this.baseURL}/guarantors/${id}/verify/`,
        {
          action,
          notes,
        }
      )
      return response.data
    } catch (error) {
      console.error('Error verifying guarantor:', error)
      throw error
    }
  }
}

export const customerAPI = new CustomerAPI()
export type { CustomerAPI }    and   // frontend/src/hooks/useCustomers.ts
import { useState, useCallback } from 'react'
import {
  customerAPI,
  type Customer,
  type CustomerDetailResponse,
  type CustomerListResponse,
  type CustomerStatsResponse,
  type CustomerListParams,
  type CustomerCreateData,
  type CustomerUpdateData,
  type Employment,
  type EmploymentCreateData,
  type Guarantor,
  type GuarantorCreateData,
} from '@/lib/api/customers'

interface UseCustomersReturn {
  // State
  isLoading: boolean
  error: string | null

  // Customer methods
  fetchCustomers: (params?: CustomerListParams) => Promise<CustomerListResponse>
  fetchCustomer: (id: string) => Promise<CustomerDetailResponse>
  createCustomer: (data: CustomerCreateData) => Promise<Customer>
  updateCustomer: (id: string, data: CustomerUpdateData) => Promise<Customer>
  deleteCustomer: (id: string) => Promise<void>
  searchCustomers: (query: string, searchType?: string) => Promise<Customer[]>
  getCustomerStats: () => Promise<CustomerStatsResponse>
  blacklistCustomer: (id: string, reason: string) => Promise<Customer>
  activateCustomer: (id: string) => Promise<Customer>
  exportCustomers: (format: 'excel' | 'csv', filters?: any) => Promise<Blob>
  importCustomers: (file: File) => Promise<any>

  // Employment methods
  getEmployment: (customerId: string) => Promise<Employment>
  updateEmployment: (customerId: string, data: EmploymentCreateData) => Promise<Employment>

  // Guarantor methods
  getGuarantors: (customerId: string) => Promise<Guarantor[]>
  createGuarantor: (customerId: string, data: GuarantorCreateData) => Promise<Guarantor>
  getGuarantor: (id: string) => Promise<Guarantor>
  updateGuarantor: (id: string, data: Partial<GuarantorCreateData>) => Promise<Guarantor>
  deleteGuarantor: (id: string) => Promise<void>
  verifyGuarantor: (id: string, action: 'verify' | 'reject', notes: string) => Promise<Guarantor>

  // Utility
  clearError: () => void
}

export const useCustomers = (): UseCustomersReturn => {
  const [isLoading, setIsLoading] = useState(false)
  const [error, setError] = useState<string | null>(null)

  /* ===== CUSTOMER METHODS ===== */

  const fetchCustomers = useCallback(
    async (params?: CustomerListParams): Promise<CustomerListResponse> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.getCustomers(params)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to fetch customers'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const fetchCustomer = useCallback(async (id: string): Promise<CustomerDetailResponse> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.getCustomer(id)
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage = err.response?.data?.detail || err.message || 'Failed to fetch customer'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const createCustomer = useCallback(
    async (data: CustomerCreateData): Promise<Customer> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.createCustomer(data)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage = err.response?.data?.detail || err.message || 'Failed to create customer'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const updateCustomer = useCallback(
    async (id: string, data: CustomerUpdateData): Promise<Customer> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.updateCustomer(id, data)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage = err.response?.data?.detail || err.message || 'Failed to update customer'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const deleteCustomer = useCallback(async (id: string): Promise<void> => {
    setIsLoading(true)
    setError(null)
    try {
      await customerAPI.deleteCustomer(id)
      setIsLoading(false)
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage = err.response?.data?.detail || err.message || 'Failed to delete customer'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const searchCustomers = useCallback(
    async (query: string, searchType?: string): Promise<Customer[]> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.searchCustomers(query, searchType)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to search customers'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const getCustomerStats = useCallback(async (): Promise<CustomerStatsResponse> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.getCustomerStats()
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to fetch customer statistics'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const blacklistCustomer = useCallback(
    async (id: string, reason: string): Promise<Customer> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.blacklistCustomer(id, reason)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to blacklist customer'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const activateCustomer = useCallback(async (id: string): Promise<Customer> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.activateCustomer(id)
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to activate customer'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const exportCustomers = useCallback(
    async (format: 'excel' | 'csv', filters?: any): Promise<Blob> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.exportCustomers(format, filters)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to export customers'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const importCustomers = useCallback(async (file: File): Promise<any> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.importCustomers(file)
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to import customers'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  /* ===== EMPLOYMENT METHODS ===== */

  const getEmployment = useCallback(async (customerId: string): Promise<Employment> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.getEmployment(customerId)
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to fetch employment'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const updateEmployment = useCallback(
    async (customerId: string, data: EmploymentCreateData): Promise<Employment> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.updateEmployment(customerId, data)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to update employment'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  /* ===== GUARANTOR METHODS ===== */

  const getGuarantors = useCallback(async (customerId: string): Promise<Guarantor[]> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.getGuarantors(customerId)
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to fetch guarantors'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const createGuarantor = useCallback(
    async (customerId: string, data: GuarantorCreateData): Promise<Guarantor> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.createGuarantor(customerId, data)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to create guarantor'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const getGuarantor = useCallback(async (id: string): Promise<Guarantor> => {
    setIsLoading(true)
    setError(null)
    try {
      const response = await customerAPI.getGuarantor(id)
      setIsLoading(false)
      return response
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to fetch guarantor'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const updateGuarantor = useCallback(
    async (id: string, data: Partial<GuarantorCreateData>): Promise<Guarantor> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.updateGuarantor(id, data)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to update guarantor'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  const deleteGuarantor = useCallback(async (id: string): Promise<void> => {
    setIsLoading(true)
    setError(null)
    try {
      await customerAPI.deleteGuarantor(id)
      setIsLoading(false)
    } catch (err: any) {
      setIsLoading(false)
      const errorMessage =
        err.response?.data?.detail || err.message || 'Failed to delete guarantor'
      setError(errorMessage)
      throw new Error(errorMessage)
    }
  }, [])

  const verifyGuarantor = useCallback(
    async (id: string, action: 'verify' | 'reject', notes: string): Promise<Guarantor> => {
      setIsLoading(true)
      setError(null)
      try {
        const response = await customerAPI.verifyGuarantor(id, action, notes)
        setIsLoading(false)
        return response
      } catch (err: any) {
        setIsLoading(false)
        const errorMessage =
          err.response?.data?.detail || err.message || 'Failed to verify guarantor'
        setError(errorMessage)
        throw new Error(errorMessage)
      }
    },
    []
  )

  /* ===== UTILITY ===== */

  const clearError = useCallback(() => {
    setError(null)
  }, [])

  return {
    // State
    isLoading,
    error,

    // Customer methods
    fetchCustomers,
    fetchCustomer,
    createCustomer,
    updateCustomer,
    deleteCustomer,
    searchCustomers,
    getCustomerStats,
    blacklistCustomer,
    activateCustomer,
    exportCustomers,
    importCustomers,

    // Employment methods
    getEmployment,
    updateEmployment,

    // Guarantor methods
    getGuarantors,
    createGuarantor,
    getGuarantor,
    updateGuarantor,
    deleteGuarantor,
    verifyGuarantor,

    // Utility
    clearError,
  }
}    and    // frontend/src/store/slices/customerSlice.ts
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit'
import { customerAPI } from '@/lib/api/customers'
import type {
  Customer,
  CustomerListParams,
  CustomerCreateData,
  CustomerUpdateData,
  Employment,
  EmploymentCreateData,
  Guarantor,
  GuarantorCreateData,
  CustomerDetailResponse,
  CustomerStatsResponse,
} from '@/lib/api/customers'

/* =====================================================
 * State Interface
 * ===================================================== */

interface CustomerState {
  // List state
  customers: Customer[]
  customersLoading: boolean
  customersError: string | null
  customersPagination: {
    page: number
    page_size: number
    total: number
    total_pages: number
  }

  // Detail state
  selectedCustomer: CustomerDetailResponse | null
  selectedCustomerLoading: boolean
  selectedCustomerError: string | null

  // Stats state
  stats: CustomerStatsResponse | null
  statsLoading: boolean
  statsError: string | null

  // Employment state
  employment: Employment | null
  employmentLoading: boolean
  employmentError: string | null

  // Guarantors state
  guarantors: Guarantor[]
  selectedGuarantor: Guarantor | null
  guarantorsLoading: boolean
  guarantorsError: string | null

  // Search state
  searchResults: Customer[]
  searchLoading: boolean
  searchError: string | null

  // Filters
  filters: {
    search?: string
    status?: string
    gender?: string
    county?: string
    risk_level?: string
  }
}

/* =====================================================
 * Initial State
 * ===================================================== */

const initialState: CustomerState = {
  // List state
  customers: [],
  customersLoading: false,
  customersError: null,
  customersPagination: {
    page: 1,
    page_size: 20,
    total: 0,
    total_pages: 0,
  },

  // Detail state
  selectedCustomer: null,
  selectedCustomerLoading: false,
  selectedCustomerError: null,

  // Stats state
  stats: null,
  statsLoading: false,
  statsError: null,

  // Employment state
  employment: null,
  employmentLoading: false,
  employmentError: null,

  // Guarantors state
  guarantors: [],
  selectedGuarantor: null,
  guarantorsLoading: false,
  guarantorsError: null,

  // Search state
  searchResults: [],
  searchLoading: false,
  searchError: null,

  // Filters
  filters: {},
}

/* =====================================================
 * Async Thunks
 * ===================================================== */

export const fetchCustomers = createAsyncThunk(
  'customers/fetchCustomers',
  async (params: CustomerListParams, { rejectWithValue }) => {
    try {
      return await customerAPI.getCustomers(params)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch customers')
    }
  }
)

export const fetchCustomerById = createAsyncThunk(
  'customers/fetchCustomerById',
  async (id: string, { rejectWithValue }) => {
    try {
      return await customerAPI.getCustomer(id)
    } catch (error: any) {
      return rejectWithValue(error.response?.data?.detail || 'Failed to fetch customer')
    }
  }
)

export const createCustomer = createAsyncThunk(
  'customers/createCustomer',
  async (data: CustomerCreateData, { rejectWithValue }) => {
    try {
      return await customerAPI.createCustomer(data)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to create customer')
    }
  }
)

export const updateCustomer = createAsyncThunk(
  'customers/updateCustomer',
  async ({ id, data }: { id: string; data: CustomerUpdateData }, { rejectWithValue }) => {
    try {
      return await customerAPI.updateCustomer(id, data)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to update customer')
    }
  }
)

export const deleteCustomer = createAsyncThunk(
  'customers/deleteCustomer',
  async (id: string, { rejectWithValue }) => {
    try {
      await customerAPI.deleteCustomer(id)
      return id
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to delete customer')
    }
  }
)

export const searchCustomers = createAsyncThunk(
  'customers/searchCustomers',
  async ({ query, searchType }: { query: string; searchType?: string }, { rejectWithValue }) => {
    try {
      return await customerAPI.searchCustomers(query, searchType)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to search customers')
    }
  }
)

export const fetchCustomerStats = createAsyncThunk(
  'customers/fetchStats',
  async (_, { rejectWithValue }) => {
    try {
      return await customerAPI.getCustomerStats()
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch customer stats')
    }
  }
)

export const blacklistCustomer = createAsyncThunk(
  'customers/blacklistCustomer',
  async ({ id, reason }: { id: string; reason: string }, { rejectWithValue }) => {
    try {
      return await customerAPI.blacklistCustomer(id, reason)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to blacklist customer')
    }
  }
)

export const activateCustomer = createAsyncThunk(
  'customers/activateCustomer',
  async (id: string, { rejectWithValue }) => {
    try {
      return await customerAPI.activateCustomer(id)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to activate customer')
    }
  }
)

export const fetchEmployment = createAsyncThunk(
  'customers/fetchEmployment',
  async (customerId: string, { rejectWithValue }) => {
    try {
      return await customerAPI.getEmployment(customerId)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch employment')
    }
  }
)

export const updateEmployment = createAsyncThunk(
  'customers/updateEmployment',
  async (
    { customerId, data }: { customerId: string; data: EmploymentCreateData },
    { rejectWithValue }
  ) => {
    try {
      return await customerAPI.updateEmployment(customerId, data)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to update employment')
    }
  }
)

export const fetchGuarantors = createAsyncThunk(
  'customers/fetchGuarantors',
  async (customerId: string, { rejectWithValue }) => {
    try {
      return await customerAPI.getGuarantors(customerId)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch guarantors')
    }
  }
)

export const createGuarantor = createAsyncThunk(
  'customers/createGuarantor',
  async (
    { customerId, data }: { customerId: string; data: GuarantorCreateData },
    { rejectWithValue }
  ) => {
    try {
      return await customerAPI.createGuarantor(customerId, data)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to create guarantor')
    }
  }
)

export const fetchGuarantorById = createAsyncThunk(
  'customers/fetchGuarantorById',
  async (id: string, { rejectWithValue }) => {
    try {
      return await customerAPI.getGuarantor(id)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch guarantor')
    }
  }
)

export const updateGuarantor = createAsyncThunk(
  'customers/updateGuarantor',
  async ({ id, data }: { id: string; data: Partial<GuarantorCreateData> }, { rejectWithValue }) => {
    try {
      return await customerAPI.updateGuarantor(id, data)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to update guarantor')
    }
  }
)

export const deleteGuarantor = createAsyncThunk(
  'customers/deleteGuarantor',
  async (id: string, { rejectWithValue }) => {
    try {
      await customerAPI.deleteGuarantor(id)
      return id
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to delete guarantor')
    }
  }
)

export const verifyGuarantor = createAsyncThunk(
  'customers/verifyGuarantor',
  async (
    { id, action, notes }: { id: string; action: 'verify' | 'reject'; notes: string },
    { rejectWithValue }
  ) => {
    try {
      return await customerAPI.verifyGuarantor(id, action, notes)
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to verify guarantor')
    }
  }
)

/* =====================================================
 * Slice
 * ===================================================== */

const customerSlice = createSlice({
  name: 'customers',
  initialState,
  reducers: {
    clearCustomersError: (state) => {
      state.customersError = null
    },
    clearSelectedCustomerError: (state) => {
      state.selectedCustomerError = null
    },
    clearStatsError: (state) => {
      state.statsError = null
    },
    clearEmploymentError: (state) => {
      state.employmentError = null
    },
    clearGuarantorsError: (state) => {
      state.guarantorsError = null
    },
    clearSearchError: (state) => {
      state.searchError = null
    },
    clearSelectedCustomer: (state) => {
      state.selectedCustomer = null
    },
    clearSelectedGuarantor: (state) => {
      state.selectedGuarantor = null
    },
    setFilters: (state, action: PayloadAction<Partial<CustomerState['filters']>>) => {
      state.filters = { ...state.filters, ...action.payload }
    },
    setCustomerPage: (state, action: PayloadAction<number>) => {
      state.customersPagination.page = action.payload
    },
  },
  extraReducers: (builder) => {
    // fetchCustomers
    builder
      .addCase(fetchCustomers.pending, (state) => {
        state.customersLoading = true
        state.customersError = null
      })
      .addCase(fetchCustomers.fulfilled, (state, action) => {
        state.customersLoading = false
        state.customers = action.payload.results
        state.customersPagination = {
          page: 1,
          page_size: 20,
          total: action.payload.count,
          total_pages: Math.ceil(action.payload.count / 20),
        }
      })
      .addCase(fetchCustomers.rejected, (state, action) => {
        state.customersLoading = false
        state.customersError = action.payload as string
      })

    // fetchCustomerById
    builder
      .addCase(fetchCustomerById.pending, (state) => {
        state.selectedCustomerLoading = true
        state.selectedCustomerError = null
      })
      .addCase(fetchCustomerById.fulfilled, (state, action) => {
        state.selectedCustomerLoading = false
        state.selectedCustomer = action.payload
      })
      .addCase(fetchCustomerById.rejected, (state, action) => {
        state.selectedCustomerLoading = false
        state.selectedCustomerError = action.payload as string
      })

    // createCustomer
    builder
      .addCase(createCustomer.pending, (state) => {
        state.customersLoading = true
        state.customersError = null
      })
      .addCase(createCustomer.fulfilled, (state, action) => {
        state.customersLoading = false
        state.customers.unshift(action.payload)
      })
      .addCase(createCustomer.rejected, (state, action) => {
        state.customersLoading = false
        state.customersError = action.payload as string
      })

    // updateCustomer
    builder
      .addCase(updateCustomer.pending, (state) => {
        state.customersLoading = true
        state.customersError = null
      })
      .addCase(updateCustomer.fulfilled, (state, action) => {
        state.customersLoading = false
        const index = state.customers.findIndex((c) => c.id === action.payload.id)
        if (index !== -1) {
          state.customers[index] = action.payload
        }
        if (state.selectedCustomer?.id === action.payload.id) {
          state.selectedCustomer = { ...state.selectedCustomer, ...action.payload }
        }
      })
      .addCase(updateCustomer.rejected, (state, action) => {
        state.customersLoading = false
        state.customersError = action.payload as string
      })

    // deleteCustomer
    builder
      .addCase(deleteCustomer.pending, (state) => {
        state.customersLoading = true
        state.customersError = null
      })
      .addCase(deleteCustomer.fulfilled, (state, action) => {
        state.customersLoading = false
        state.customers = state.customers.filter((c) => c.id !== action.payload)
        if (state.selectedCustomer?.id === action.payload) {
          state.selectedCustomer = null
        }
      })
      .addCase(deleteCustomer.rejected, (state, action) => {
        state.customersLoading = false
        state.customersError = action.payload as string
      })

    // searchCustomers
    builder
      .addCase(searchCustomers.pending, (state) => {
        state.searchLoading = true
        state.searchError = null
      })
      .addCase(searchCustomers.fulfilled, (state, action) => {
        state.searchLoading = false
        state.searchResults = action.payload
      })
      .addCase(searchCustomers.rejected, (state, action) => {
        state.searchLoading = false
        state.searchError = action.payload as string
      })

    // fetchCustomerStats
    builder
      .addCase(fetchCustomerStats.pending, (state) => {
        state.statsLoading = true
        state.statsError = null
      })
      .addCase(fetchCustomerStats.fulfilled, (state, action) => {
        state.statsLoading = false
        state.stats = action.payload
      })
      .addCase(fetchCustomerStats.rejected, (state, action) => {
        state.statsLoading = false
        state.statsError = action.payload as string
      })

    // blacklistCustomer
    builder
      .addCase(blacklistCustomer.pending, (state) => {
        state.customersLoading = true
        state.customersError = null
      })
      .addCase(blacklistCustomer.fulfilled, (state, action) => {
        state.customersLoading = false
        const index = state.customers.findIndex((c) => c.id === action.payload.id)
        if (index !== -1) {
          state.customers[index] = action.payload
        }
        if (state.selectedCustomer?.id === action.payload.id) {
          state.selectedCustomer = { ...state.selectedCustomer, ...action.payload }
        }
      })
      .addCase(blacklistCustomer.rejected, (state, action) => {
        state.customersLoading = false
        state.customersError = action.payload as string
      })

    // activateCustomer
    builder
      .addCase(activateCustomer.pending, (state) => {
        state.customersLoading = true
        state.customersError = null
      })
      .addCase(activateCustomer.fulfilled, (state, action) => {
        state.customersLoading = false
        const index = state.customers.findIndex((c) => c.id === action.payload.id)
        if (index !== -1) {
          state.customers[index] = action.payload
        }
        if (state.selectedCustomer?.id === action.payload.id) {
          state.selectedCustomer = { ...state.selectedCustomer, ...action.payload }
        }
      })
      .addCase(activateCustomer.rejected, (state, action) => {
        state.customersLoading = false
        state.customersError = action.payload as string
      })

    // fetchEmployment
    builder
      .addCase(fetchEmployment.pending, (state) => {
        state.employmentLoading = true
        state.employmentError = null
      })
      .addCase(fetchEmployment.fulfilled, (state, action) => {
        state.employmentLoading = false
        state.employment = action.payload
      })
      .addCase(fetchEmployment.rejected, (state, action) => {
        state.employmentLoading = false
        state.employmentError = action.payload as string
      })

    // updateEmployment
    builder
      .addCase(updateEmployment.pending, (state) => {
        state.employmentLoading = true
        state.employmentError = null
      })
      .addCase(updateEmployment.fulfilled, (state, action) => {
        state.employmentLoading = false
        state.employment = action.payload
        if (state.selectedCustomer) {
          state.selectedCustomer.employment = action.payload
        }
      })
      .addCase(updateEmployment.rejected, (state, action) => {
        state.employmentLoading = false
        state.employmentError = action.payload as string
      })

    // fetchGuarantors
    builder
      .addCase(fetchGuarantors.pending, (state) => {
        state.guarantorsLoading = true
        state.guarantorsError = null
      })
      .addCase(fetchGuarantors.fulfilled, (state, action) => {
        state.guarantorsLoading = false
        state.guarantors = action.payload
      })
      .addCase(fetchGuarantors.rejected, (state, action) => {
        state.guarantorsLoading = false
        state.guarantorsError = action.payload as string
      })

    // createGuarantor
    builder
      .addCase(createGuarantor.pending, (state) => {
        state.guarantorsLoading = true
        state.guarantorsError = null
      })
      .addCase(createGuarantor.fulfilled, (state, action) => {
        state.guarantorsLoading = false
        state.guarantors.unshift(action.payload)
      })
      .addCase(createGuarantor.rejected, (state, action) => {
        state.guarantorsLoading = false
        state.guarantorsError = action.payload as string
      })

    // fetchGuarantorById
    builder
      .addCase(fetchGuarantorById.pending, (state) => {
        state.guarantorsLoading = true
        state.guarantorsError = null
      })
      .addCase(fetchGuarantorById.fulfilled, (state, action) => {
        state.guarantorsLoading = false
        state.selectedGuarantor = action.payload
      })
      .addCase(fetchGuarantorById.rejected, (state, action) => {
        state.guarantorsLoading = false
        state.guarantorsError = action.payload as string
      })

    // updateGuarantor
    builder
      .addCase(updateGuarantor.pending, (state) => {
        state.guarantorsLoading = true
        state.guarantorsError = null
      })
      .addCase(updateGuarantor.fulfilled, (state, action) => {
        state.guarantorsLoading = false
        const index = state.guarantors.findIndex((g) => g.id === action.payload.id)
        if (index !== -1) {
          state.guarantors[index] = action.payload
        }
        if (state.selectedGuarantor?.id === action.payload.id) {
          state.selectedGuarantor = action.payload
        }
      })
      .addCase(updateGuarantor.rejected, (state, action) => {
        state.guarantorsLoading = false
        state.guarantorsError = action.payload as string
      })

    // deleteGuarantor
    builder
      .addCase(deleteGuarantor.pending, (state) => {
        state.guarantorsLoading = true
        state.guarantorsError = null
      })
      .addCase(deleteGuarantor.fulfilled, (state, action) => {
        state.guarantorsLoading = false
        state.guarantors = state.guarantors.filter((g) => g.id !== action.payload)
        if (state.selectedGuarantor?.id === action.payload) {
          state.selectedGuarantor = null
        }
      })
      .addCase(deleteGuarantor.rejected, (state, action) => {
        state.guarantorsLoading = false
        state.guarantorsError = action.payload as string
      })

    // verifyGuarantor
    builder
      .addCase(verifyGuarantor.pending, (state) => {
        state.guarantorsLoading = true
        state.guarantorsError = null
      })
      .addCase(verifyGuarantor.fulfilled, (state, action) => {
        state.guarantorsLoading = false
        const index = state.guarantors.findIndex((g) => g.id === action.payload.id)
        if (index !== -1) {
          state.guarantors[index] = action.payload
        }
        if (state.selectedGuarantor?.id === action.payload.id) {
          state.selectedGuarantor = action.payload
        }
      })
      .addCase(verifyGuarantor.rejected, (state, action) => {
        state.guarantorsLoading = false
        state.guarantorsError = action.payload as string
      })
  },
})

export const {
  clearCustomersError,
  clearSelectedCustomerError,
  clearStatsError,
  clearEmploymentError,
  clearGuarantorsError,
  clearSearchError,
  clearSelectedCustomer,
  clearSelectedGuarantor,
  setFilters,
  setCustomerPage,
} = customerSlice.actions

export default customerSlice.reducer     and       // frontend/src/types/customers.ts
// ===== CUSTOMER TYPES =====
export interface Customer {
  id: string
  customer_number: string
  first_name: string
  last_name: string
  middle_name?: string
  full_name: string
  email?: string
  phone_number: string
  date_of_birth: string
  gender: 'M' | 'F' | 'O'
  id_number: string
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE' | 'ALIEN_CARD'
  id_expiry_date?: string
  nationality: string
  physical_address: string
  postal_address?: string
  county: string
  sub_county: string
  ward?: string
  bank_name?: string
  bank_account_number?: string
  bank_branch?: string
  marital_status?: 'SINGLE' | 'MARRIED' | 'DIVORCED' | 'WIDOWED' | 'SEPARATED'
  status: 'ACTIVE' | 'INACTIVE' | 'BLACKLISTED' | 'DECEASED'
  credit_score: number
  risk_level: 'LOW' | 'MEDIUM' | 'HIGH'
  age: number
  is_active: boolean
  is_blacklisted: boolean
  total_loans: number
  active_loans: number
  total_loan_amount: number
  outstanding_balance: number
  loan_performance: number
  registration_date: string
  last_updated: string
  created_at: string
  updated_at: string
  notes?: string
  referred_by?: string
  user?: string
  created_by?: string
  updated_by?: string
}

// ===== EMPLOYMENT TYPES =====
export interface Employment {
  id: string
  customer: string
  employment_type: 'EMPLOYED' | 'SELF_EMPLOYED' | 'UNEMPLOYED' | 'STUDENT' | 'RETIRED'
  sector: string
  occupation: string
  employer_name?: string
  employer_address?: string
  employer_phone?: string
  employer_email?: string
  job_title?: string
  department?: string
  employee_number?: string
  date_employed?: string
  years_of_service: number
  monthly_income: number
  other_income: number
  total_monthly_income: number
  payment_frequency: string
  next_pay_date?: string
  business_name?: string
  business_type?: string
  business_registration?: string
  business_start_date?: string
  number_of_employees: number
  is_verified: boolean
  verification_date?: string
  verification_method?: string
  verification_notes?: string
  employment_letter?: string
  pay_slips?: string
  business_permit?: string
  notes?: string
  created_at: string
  updated_at: string
}

// ===== GUARANTOR TYPES =====
export interface Guarantor {
  id: string
  customer: string
  first_name: string
  middle_name?: string
  last_name: string
  full_name: string
  phone_number: string
  email?: string
  physical_address: string
  county: string
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE'
  id_number: string
  guarantor_type: 'PERSONAL' | 'CORPORATE' | 'INSTITUTIONAL'
  relationship: 'SPOUSE' | 'PARENT' | 'SIBLING' | 'FRIEND' | 'COLLEAGUE' | 'RELATIVE' | 'OTHER'
  occupation: string
  employer?: string
  monthly_income: number
  id_document?: string
  passport_photo?: string
  is_active: boolean
  verification_status: 'PENDING' | 'VERIFIED' | 'REJECTED'
  is_verified?: boolean
  verification_date?: string
  verification_notes?: string
  notes?: string
  created_at: string
  updated_at: string
}

// ===== API RESPONSE TYPES =====
export interface CustomerListResponse {
  results: Customer[]
  count: number
  next: string | null
  previous: string | null
}

export interface CustomerDetailResponse extends Customer {
  loan_statistics?: {
    total_loans: number
    active_loans: number
    total_borrowed: number
    total_outstanding: number
    total_repaid: number
  }
  guarantors?: Guarantor[]
  employment?: Employment
}

export interface CustomerStatsResponse {
  total_customers: number
  active_customers: number
  blacklisted_customers: number
  new_customers_today: number
  gender_distribution: Array<{ gender: string; count: number }>
  status_distribution: Array<{ status: string; count: number }>
  top_counties: Array<{ county: string; count: number }>
  monthly_registrations: Array<{ month: string; count: number }>
  loan_statistics: {
    customers_with_loans: number
    customers_with_active_loans: number
    customers_with_overdue_loans: number
  }
}

// ===== FORM DATA TYPES =====
export interface CustomerFormData {
  first_name: string
  last_name: string
  middle_name?: string
  date_of_birth: string
  gender: 'M' | 'F' | 'O'
  marital_status?: 'SINGLE' | 'MARRIED' | 'DIVORCED' | 'WIDOWED' | 'SEPARATED'
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE' | 'ALIEN_CARD'
  id_number: string
  id_expiry_date?: string
  nationality?: string
  phone_number: string
  email?: string
  postal_address?: string
  physical_address: string
  county: string
  sub_county: string
  ward?: string
  bank_name?: string
  bank_account_number?: string
  bank_branch?: string
  notes?: string
  referred_by?: string
  create_user_account?: boolean
  user_password?: string
}

export interface EmploymentFormData {
  employment_type: 'EMPLOYED' | 'SELF_EMPLOYED' | 'UNEMPLOYED' | 'STUDENT' | 'RETIRED'
  sector: string
  occupation: string
  employer_name?: string
  employer_address?: string
  employer_phone?: string
  employer_email?: string
  job_title?: string
  department?: string
  employee_number?: string
  date_employed?: string
  monthly_income: number
  other_income: number
  payment_frequency: string
  next_pay_date?: string
  business_name?: string
  business_type?: string
  business_registration?: string
  business_start_date?: string
  number_of_employees: number
  notes?: string
}

export interface GuarantorFormData {
  first_name: string
  middle_name?: string
  last_name: string
  phone_number: string
  email?: string
  physical_address: string
  county: string
  id_type: 'NATIONAL_ID' | 'PASSPORT' | 'DRIVING_LICENSE'
  id_number: string
  guarantor_type: 'PERSONAL' | 'CORPORATE' | 'INSTITUTIONAL'
  relationship: 'SPOUSE' | 'PARENT' | 'SIBLING' | 'FRIEND' | 'COLLEAGUE' | 'RELATIVE' | 'OTHER'
  occupation: string
  employer?: string
  monthly_income: number
  notes?: string
}

// ===== FILTER TYPES =====
export interface CustomerFilters {
  search?: string
  status?: string
  gender?: string
  marital_status?: string
  county?: string
  risk_level?: string
  active?: boolean | string
  blacklisted?: boolean | string
  has_loans?: boolean | string
  start_date?: string
  end_date?: string
}

// ===== SEARCH TYPES =====
export type SearchType = 'basic' | 'name' | 'phone' | 'id' | 'customer_number'

// ===== CONSTANTS =====

export const NATIONALITY_OPTIONS = [
  { value: 'KENYAN', label: 'Kenyan' },
  { value: 'OTHER', label: 'Other' },
]

export const GENDER_OPTIONS = [
  { value: 'M', label: 'Male' },
  { value: 'F', label: 'Female' },
  { value: 'O', label: 'Other' },
]

export const ID_TYPE_OPTIONS = [
  { value: 'NATIONAL_ID', label: 'National ID' },
  { value: 'PASSPORT', label: 'Passport' },
  { value: 'DRIVING_LICENSE', label: 'Driving License' },
  { value: 'ALIEN_CARD', label: 'Alien Card' },
]

export const GUARANTOR_TYPE_OPTIONS = [
  { value: 'PERSONAL', label: 'Personal' },
  { value: 'CORPORATE', label: 'Corporate' },
  { value: 'INSTITUTIONAL', label: 'Institutional' },
]

export const RELATIONSHIP_OPTIONS = [
  { value: 'SPOUSE', label: 'Spouse' },
  { value: 'PARENT', label: 'Parent' },
  { value: 'SIBLING', label: 'Sibling' },
  { value: 'FRIEND', label: 'Friend' },
  { value: 'COLLEAGUE', label: 'Colleague' },
  { value: 'RELATIVE', label: 'Relative' },
  { value: 'OTHER', label: 'Other' },
]

export const MARITAL_STATUS_OPTIONS = [
  { value: 'SINGLE', label: 'Single' },
  { value: 'MARRIED', label: 'Married' },
  { value: 'DIVORCED', label: 'Divorced' },
  { value: 'WIDOWED', label: 'Widowed' },
  { value: 'SEPARATED', label: 'Separated' },
]

export const CUSTOMER_STATUS_OPTIONS = [
  { value: 'ACTIVE', label: 'Active' },
  { value: 'INACTIVE', label: 'Inactive' },
  { value: 'BLACKLISTED', label: 'Blacklisted' },
  { value: 'DECEASED', label: 'Deceased' },
]

export const RISK_LEVEL_OPTIONS = [
  { value: 'LOW', label: 'Low Risk' },
  { value: 'MEDIUM', label: 'Medium Risk' },
  { value: 'HIGH', label: 'High Risk' },
]

export const EMPLOYMENT_TYPE_OPTIONS = [
  { value: 'EMPLOYED', label: 'Employed' },
  { value: 'SELF_EMPLOYED', label: 'Self-Employed' },
  { value: 'UNEMPLOYED', label: 'Unemployed' },
  { value: 'STUDENT', label: 'Student' },
  { value: 'RETIRED', label: 'Retired' },
]

export const SECTOR_OPTIONS = [
  { value: 'GOVERNMENT', label: 'Government' },
  { value: 'PRIVATE', label: 'Private Sector' },
  { value: 'NGO', label: 'Non-Governmental Organization' },
  { value: 'INFORMAL', label: 'Informal Sector' },
  { value: 'AGRICULTURE', label: 'Agriculture' },
  { value: 'MANUFACTURING', label: 'Manufacturing' },
  { value: 'SERVICES', label: 'Services' },
  { value: 'CONSTRUCTION', label: 'Construction' },
  { value: 'HEALTH', label: 'Health' },
  { value: 'EDUCATION', label: 'Education' },
  { value: 'OTHER', label: 'Other' },
]

export const PAYMENT_FREQUENCY_OPTIONS = [
  { value: 'DAILY', label: 'Daily' },
  { value: 'WEEKLY', label: 'Weekly' },
  { value: 'BIWEEKLY', label: 'Bi-Weekly' },
  { value: 'MONTHLY', label: 'Monthly' },
  { value: 'QUARTERLY', label: 'Quarterly' },
  { value: 'ANNUALLY', label: 'Annually' },
  { value: 'IRREGULAR', label: 'Irregular' },
]

// ===== HELPER FUNCTIONS =====

export const formatPhoneNumber = (phone: string): string => {
  if (!phone) return ''
  // Ensure phone starts with +254
  if (phone.startsWith('0')) {
    return '+254' + phone.substring(1)
  }
  if (phone.startsWith('254')) {
    return '+' + phone
  }
  return phone
}

export const calculateAge = (dateOfBirth: string): number => {
  const today = new Date()
  const birthDate = new Date(dateOfBirth)
  let age = today.getFullYear() - birthDate.getFullYear()
  const monthDiff = today.getMonth() - birthDate.getMonth()

  if (monthDiff < 0 || (monthDiff === 0 && today.getDate() < birthDate.getDate())) {
    age--
  }

  return age
}

export const getStatusColor = (status: string): string => {
  switch (status) {
    case 'ACTIVE':
      return 'success'
    case 'INACTIVE':
      return 'warning'
    case 'BLACKLISTED':
      return 'error'
    case 'DECEASED':
      return 'default'
    default:
      return 'default'
  }
}

export const getRiskLevelColor = (riskLevel: string): string => {
  switch (riskLevel) {
    case 'LOW':
      return 'success'
    case 'MEDIUM':
      return 'warning'
    case 'HIGH':
      return 'error'
    default:
      return 'default'
  }
}

export const getVerificationStatusColor = (status: string): string => {
  switch (status) {
    case 'VERIFIED':
      return 'success'
    case 'PENDING':
      return 'warning'
    case 'REJECTED':
      return 'error'
    default:
      return 'default'
  }
}     now give me  comprehensive                                                                                                             │       ├── pages/  for    
│       │   ├── customers/
│       │   │   ├── routes.tsx
│       │   │   ├── page1.tsx
│       │   │   ├── page2.tsx
│       │   │   └── maybe_page_n.tsx   and  components                                                                                           │       |─ components/   
│       │   ├── customers/
│       │   |   ├── component1.tsx        
│       │   |   ├── component2.tsx          
│       │   |   └── component_n.tsx